// 2.1

// БАЗОВЫЕ ТИПЫ ////////////////////////////////////////////////////

// в ts мы можем присваивать тип значения переменной
// как явно так и не явно, а во время первого обявленния
// тогда компилятор присвоит значение автоматом

const num = 6;
const num1: number = 6;

//одно и тоже, но лучше читается явный

// num = 'str'; //Ошибка
//num1 = 'str'; //Ошибка

//анотация типа переменной обявляется после двоеточия
// и имеет следующия значения

// string,
// boolean,
// number,

// //и так понятно...

// symbol - дла уникалных значения конструктора Symbol,

// any - для любых значений. По сути получится просто js.

// unkown - аналог any с которым нельзя проводить едйствий не с узив до более конкретного типа

// never - для представления невозможного кода
//дла бесконечных функцийб либо функций которые выбрасывают ошибку
// const loger = () => {
//     while(true){
//         console.log('hi');
//     }
// };
//преременной компилятор автоматом присвоит значение loger => never

// void - отсутствие значения
//const loger = (errMsg: string) => {
//      console.log(errMsg);
// };
//для функций ничего не возвращающих loger => void

//следует избегать явных определений там где и так очевидно что подставит компилятор
let str: string = 'string';//тут уже излишне

//также можно использоать лиьералы в качестве анотаций типов
let lohn: 'John Smith' = 'John Smith';
//теперь тольько строка John Smith может находится в переменной

//аннотации типов можно использовать при обявлении аргументов
//функции чтобы избежать багов с неправильными тиипами аргументов

function calcTax (city: string, income: number, depth: number): number | undefined{
    if (city === 'NY'){
        return income * 0.06 - depth * 500;
    }else if (city === 'NJ'){
        return income * 0.05 - depth * 300;
    }
};

//теперь наша функция защищена от передачи неверных типов аргументов 
//еще на стадии компиляции

//2.2

//Обеденение типов позволяет выражть значение состоящее из нескольки типов
let padding: string | number;
//для проверки встроеных типов допустим в условиях
//используется typeof
// if (typeof padding === 'number'){}

//для пользовательских inctanceof
// if (person instaenceof Person){}

//2.3

//ПОЛЬЗОВАТЕЛЬСКИЕ ТИПЫ ////////////////////////////////////////////////////

//type

//TS позволяет нам создавать собственные типы
//при помощи ключевого слова type
//также есть возможность создания классов, интерфейсов и перечислений (enum)

//type можно использовать для добавления собственных типов или обявления псевдонимов типов

type Pound = number;
type Foot = number;

type Patient = {
    height?: Foot,
    weight: Pound,
    name: string,
};
//вопросительный знак перд двоеточием означает что свойства может и не быть

const patient: Patient = {
    weight: 50,
    name: 'Jeka',
};

//также с помощю type можно описывать сигнатуры функций
type FormControl = {
    errTxt: string,
    host: string,
};

type validatorFn = (c: FormControl) => {[key: string]: any} | null;
//{[key: string]: any} означает вернуть из функции объект в котором ключем будет строка а значение чем угодно

//class

//JS нет возможности обявлять свойства классов
//но в TS она есть
//также можно обявлять анотации для параметров конструктора класса
//Конструктор - это такая функция которая вызываетс один раз при создании 
//экземпляра объека, и инициализирует его

//таеже TS представляет класификаторы уровня доступа свойств
//private, protected, public
//также есть возможность обявлять свойство readonly
//такое свойство установится раз в конструкторе и больше его изменять нельзя
//как const только для классов

//interface

//В ООП языках для описания свойств и методов в объекте пользуются конструкциями под названием 
//interface
//В TS тоже есть такая возможность с помощю ключевых слов
//interface implements
//интерфейсы не преобразуются в JS код, а служат лиш для предотвращения ошибок во время написания

interface Person {
    fName: string,
    lName: string,
    age: number,
};
//очень похоже на class
//но разница в том что к классу можно потом обращатся из кода и в JS будет создан аналогичный клас или функция

//ЕСЛИ К ПОЛЬЗОВАТЕЛЬСКОМУ ТИПУ НУЖНО ОБРАЩАТСЯ ИЛИ ГЕНЕРИТЬ ЭКЗЕМПЛЯРЫ ТО НУЖНО ВЫБРАТЬ "CLASS"
//ЕСЛИ ПРОСТО ДЛЯ СТРАХОВКИ ТИПОВ ТО INTERFACE | TYPE

//2.4

//SYSTEM TYPE COMPARASION

//В ООП существует две системы сравнения сложных типов
//базовые легко number === number -->true

//а сложные типа

type Cat = {
    paws: number,
    name: string,
};
//сравниваются либо по ссылке либо по структуре

//НОМИНАЛЬНАЯ СИСТЕМА
// номинальной системе типов структуры равны если у них одинаковые имена
//не равны даже если структура одинаков

//СТРУКТУРНАЯ СИСТЕМА
//Структурная система сравнивает по структуре
//и сушности будут равны даже если имена разные или их нет
//TS использует структурную систему

// class Person {
//     name: string;
// };

// class Customer {
//     name: string;
// };

// const cust: Customer = new Person(); //будет работать

//если сущности не одинаковой структуры

// class Person {
//     name: string;
//     age: number;
// };

// class Customer {
//     name: string;
// }

// const cust: Customer = new Person(); //будет работать
//компилятор интересует лиш свойство name class Customer
//а в Person оно есть и + еще кое что

//на оборот же

// class Person {
//     name: string;
// };

// class Customer {
//     name: string;
//     age: number;
// }

// const cust: Customer = new Person(); //выдаст ошибку
//так как сейчас Customer нужно еще свойство age а у Person его нет

//2.4

//ПОЛЬЗОВАТИЛЬСКИЕ ОБЕДЕНЕНИЯ ТИПОВ////////////////////////////////////////////////////

class SearchAction {
    actionType = 'SEARCH';

    constructor (readonly payload: {searchQuerty: string}){};
};

class SearchSuccessAction {
    actionType = 'SUCCESS';

    constructor (public payload: {searchResult: string}){};
};

class SearchFailedAction {
    actionType = 'FAILLED';
};

type SearchActons = SearchAction
                    | SearchFailedAction
                    | SearchSuccessAction;
//обявление обедененного типа

//РАЗМЕЧЕННЫЕ ОБЪЕДИНЕНИЯ - включают членов типов котроые имеют общее свойство - ДИСКРИМИНАНТ
//в зависимости от значения этого свойства можно выбрать определенный сособ действия

//ЗАЩИТА ТИПА IN

//такая защита используется для функций с обобщенными типами

interface A {a: number};
interface B {b: number};

function ABFunc (x: A | B){
    if ('a' in x) return x.a;

    if ('b' in x) return x.b;
};

//2.5

//ANY WITH UNKNOWN

//Эти типы схожи но unknown при обращении к типу поросит сузить до определенного

type PersonAddress = {
    address: string
};

let personAdr1: any;

personAdr1 = JSON.parse('{"adress": "25 Broadway"}');

console.log(personAdr1.address);

let personAdr2: unknown;

personAdr2 = JSON.parse('{"adress": "25 Broadway"}');

// console.log(personAdr2.adress);/не скомпилится
